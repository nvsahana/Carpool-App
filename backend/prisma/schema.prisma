generator client {
  provider             = "prisma-client-py"
  interface            = "asyncio"
  recursive_type_depth = 5
  binaryTargets        = ["native", "linux-musl-openssl-3.0.x", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}


model User {
  id             Int      @id @default(autoincrement())
  firstName      String
  lastName       String
  email          String   @unique
  phone          String?
  profilePath    String?  // store uploaded file path or URL
  // addresses are stored in separate tables
  companyAddress CompanyAddress? @relation("CompanyAddressUser")
  homeAddress    HomeAddress?    @relation("HomeAddressUser")
  role           String   // "driver" or "passenger"
  willingToTake  Int[]    // array of numbers (1..5) when driver (use empty array if none)
  hasDriversLicense Boolean?
  passwordHash   String? // bcrypt hashed password
  createdAt      DateTime @default(now())
  
  // Connection requests sent by this user
  sentRequests     ConnectionRequest[] @relation("SentRequests")
  // Connection requests received by this user
  receivedRequests ConnectionRequest[] @relation("ReceivedRequests")

  sentMessages     Message[]       @relation("SentMessages")
  conversations1   Conversation[]  @relation("User1Conversations")
  conversations2   Conversation[]  @relation("User2Conversations")
  
  // Carpool Groups
  drivingGroups    CarpoolGroup[]  @relation("GroupDriver")
  groupMemberships GroupMember[]
  groupRequests    GroupRequest[]  @relation("GroupRequestUser")
  groupVotes       GroupVote[]     @relation("GroupVoter")
}

model CompanyAddress {
  id        Int    @id @default(autoincrement())
  officeName String?
  street     String?
  city       String?
  zipcode    String?
  // Geospatial coordinates for PostGIS queries
  latitude  Float?
  longitude Float?

  user   User @relation("CompanyAddressUser", fields: [userId], references: [id])
  userId Int  @unique
}

model HomeAddress {
  id     Int    @id @default(autoincrement())
  street String?
  city   String?
  zipcode String?
  // Geospatial coordinates for PostGIS queries
  latitude  Float?
  longitude Float?

  user   User @relation("HomeAddressUser", fields: [userId], references: [id])
  userId Int  @unique
}

model ConnectionRequest {
  id         Int      @id @default(autoincrement())
  senderId   Int
  receiverId Int
  status     String   @default("pending") // "pending", "accepted", "rejected"
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  sender   User @relation("SentRequests", fields: [senderId], references: [id], onDelete: Cascade)
  receiver User @relation("ReceivedRequests", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId]) // Prevent duplicate requests
  @@index([receiverId, status]) // Optimize queries for pending requests
}

model Conversation {
  id        Int      @id @default(autoincrement())
  user1Id   Int
  user2Id   Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user1    User      @relation("User1Conversations", fields: [user1Id], references: [id], onDelete: Cascade)
  user2    User      @relation("User2Conversations", fields: [user2Id], references: [id], onDelete: Cascade)
  messages Message[]

  @@unique([user1Id, user2Id])
  @@index([user1Id])
  @@index([user2Id])
}

model Message {
  id             Int      @id @default(autoincrement())
  conversationId Int
  senderId       Int
  content        String   @db.Text
  isRead         Boolean  @default(false)
  createdAt      DateTime @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([senderId])
}


// ============================================
// CARPOOL GROUP SYSTEM
// Enables multi-passenger groups with atomic consensus
// ============================================

model CarpoolGroup {
  id               Int      @id @default(autoincrement())
  name             String?  // e.g., "Morning Commute to Google MTV"
  driverId         Int
  maxSeats         Int      @default(4)
  currentOccupancy Int      @default(1) // Starts at 1 (driver)
  status           String   @default("OPEN") // OPEN, FULL, CLOSED
  
  // Route endpoints (for PostGIS corridor calculation)
  // We calculate "on the way" using line from driver home â†’ office
  originLat        Float?   // Driver's home lat
  originLng        Float?   // Driver's home lng
  destLat          Float?   // Office lat
  destLng          Float?   // Office lng
  
  // Calculated estimated commute (without detours)
  baseDistanceMiles Float?
  
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  
  driver           User     @relation("GroupDriver", fields: [driverId], references: [id])
  members          GroupMember[]
  requests         GroupRequest[]
  
  @@index([status])
  @@index([driverId])
}

model GroupMember {
  id          Int      @id @default(autoincrement())
  groupId     Int
  userId      Int
  role        String   // "driver" or "passenger"
  joinedAt    DateTime @default(now())
  
  // Pickup location (passenger's home)
  pickupLat   Float?
  pickupLng   Float?
  pickupOrder Int?     // Order in the route: 1st pickup, 2nd pickup, etc.
  
  // How far off the direct route this pickup is
  detourMiles Float?
  
  group       CarpoolGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([groupId, userId])
  @@index([groupId])
  @@index([userId])
}

model GroupRequest {
  id            Int      @id @default(autoincrement())
  groupId       Int
  userId        Int      // User requesting to join
  status        String   @default("pending") // pending, approved, rejected
  
  // Atomic Consensus: all current members must approve
  votesRequired Int      // = currentOccupancy at time of request
  votesReceived Int      @default(0)
  
  // Calculated detour impact (miles off the direct route)
  detourMiles   Float?
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  group         CarpoolGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user          User         @relation("GroupRequestUser", fields: [userId], references: [id])
  votes         GroupVote[]
  
  @@unique([groupId, userId])
  @@index([groupId, status])
}

model GroupVote {
  id        Int      @id @default(autoincrement())
  requestId Int
  voterId   Int      // Group member who voted
  vote      String   // "approve" or "reject"
  votedAt   DateTime @default(now())
  
  request   GroupRequest @relation(fields: [requestId], references: [id], onDelete: Cascade)
  voter     User         @relation("GroupVoter", fields: [voterId], references: [id])
  
  @@unique([requestId, voterId])
  @@index([requestId])
}