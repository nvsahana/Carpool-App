generator client {
  provider             = "prisma-client-py"
  interface            = "asyncio"
  recursive_type_depth = 5
  binaryTargets        = ["native", "linux-musl-openssl-3.0.x", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}


model User {
  id             Int      @id @default(autoincrement())
  firstName      String
  lastName       String
  email          String   @unique
  phone          String?
  profilePath    String?  // store uploaded file path or URL
  // addresses are stored in separate tables
  companyAddress CompanyAddress? @relation("CompanyAddressUser")
  homeAddress    HomeAddress?    @relation("HomeAddressUser")
  role           String   // "driver" or "passenger"
  willingToTake  Int[]    // array of numbers (1..5) when driver (use empty array if none)
  hasDriversLicense Boolean?
  passwordHash   String? // bcrypt hashed password
  createdAt      DateTime @default(now())
  
  // Connection requests sent by this user
  sentRequests     ConnectionRequest[] @relation("SentRequests")
  // Connection requests received by this user
  receivedRequests ConnectionRequest[] @relation("ReceivedRequests")

  sentMessages     Message[]       @relation("SentMessages")
  conversations1   Conversation[]  @relation("User1Conversations")
  conversations2   Conversation[]  @relation("User2Conversations")
}

model CompanyAddress {
  id        Int    @id @default(autoincrement())
  officeName String?
  street     String?
  city       String?
  zipcode    String?

  user   User @relation("CompanyAddressUser", fields: [userId], references: [id])
  userId Int  @unique
}

model HomeAddress {
  id     Int    @id @default(autoincrement())
  street String?
  city   String?
  zipcode String?

  user   User @relation("HomeAddressUser", fields: [userId], references: [id])
  userId Int  @unique
}

model ConnectionRequest {
  id         Int      @id @default(autoincrement())
  senderId   Int
  receiverId Int
  status     String   @default("pending") // "pending", "accepted", "rejected"
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  sender   User @relation("SentRequests", fields: [senderId], references: [id], onDelete: Cascade)
  receiver User @relation("ReceivedRequests", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId]) // Prevent duplicate requests
  @@index([receiverId, status]) // Optimize queries for pending requests
}

model Conversation {
  id        Int      @id @default(autoincrement())
  user1Id   Int
  user2Id   Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user1    User      @relation("User1Conversations", fields: [user1Id], references: [id], onDelete: Cascade)
  user2    User      @relation("User2Conversations", fields: [user2Id], references: [id], onDelete: Cascade)
  messages Message[]

  @@unique([user1Id, user2Id])
  @@index([user1Id])
  @@index([user2Id])
}

model Message {
  id             Int      @id @default(autoincrement())
  conversationId Int
  senderId       Int
  content        String   @db.Text
  isRead         Boolean  @default(false)
  createdAt      DateTime @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([senderId])
}